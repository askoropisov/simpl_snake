
#include <time.h>
#include <random>
#include <iostream> // подключаем все необходимые инклюды.
#include "glut.h"
#include <ctime>
#include <vector>

int N = 40, M = 40; // т.к. змейка будем ездить по квадратикам, создадим их, для нашего окна в идеале будет 30x20 квадратов
int scale = 12; // размер квадрата. Когда OpenGL будет расчерчивать поле для игры, расстояние между гранями квадрата будет 25 пикселей

int w = scale * N; // ширина поля  
int h = scale * M; // его высота

double Zoom = 50.0;
double a, b;
float vx = 0.0, vy = 0.0, vz = 0.0;

float mass_color[11] = { 0,0.1, 0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1 };


int dir, num = 4; // 4 направления и начальный размер змеи.
struct { int x; int y; int z; } s[100]; // структура змеи, X и Y координаты, массив с длинной.

class fruct // класс фруктов, тех самых, которые будет есть наша змея
{
public:
	int x, y, z; //координаты фруктов, что и где будет находится


	void New() // паблик с новыми фруктами. Он будет вызываться в начале игры и в тот момент, когда змея съест один из фруктов
	{
		
		x = (rand() % (N-5) ); // вычисление X координаты через рандом
		y = (rand() % (M-5) ); // вычисление Y координаты через рандом
		
		z = 0;
	}

	void DrawFruct()// паблик, отрисовывающий фрукты
	{
		srand(time(NULL));
		int p = rand() % 11;
		float r = mass_color[rand() % 11];
		float g = mass_color[rand() % 11];
		float b = mass_color[rand() % 11];

		glColor3d(r,g,b); // цвет фруктов. в openGL он задается от 0 до 1, а не от 0 до 256, как многие привыкли
		glRectf(x * scale, y * scale, (x + 1) * scale, (y+1) * scale); // "Закрашиваем" квадрат выбранным цветом, таким образом в нем "появляется" фрукт
	}
} m; // масив с фруктами, таким образом, у нас появится одновременно 5 фруктов в разных местах, а не один

void Draw() // функция, которая отрисовывает линии
{
	glColor3f(1.0, 0.0, 0.0); // цвет наших линий, в данном слуае - красный
	glBegin(GL_LINES); // начинаем рисовать и указываем, что это линии
	for (int i = 0; i < w; i += scale) // отрисовываем линии в ширину
	{
		glVertex3f(i, 0, 0); glVertex3f(i, h, 0); // рисуем прямую
	}
	for (int j = 0; j < h; j += scale) //отрисовываем линии в высоту
	{
		glVertex3f(0, j, 0); glVertex3f(w, j, 0); // рисуем ту же самую прямую, но в другом направлении
	} 

	glEnd(); // конец отрисовки
}

void tick() // функция в которой будет все обновляться (двигаться змея и т.д.)
{


	for (int i = num; i > 0; --i) // движение змеи. Система остроумна и проста : блок перемешается вперед, а остальные X блоков, на X+1( 2 блок встанет на место 1, 3 на место 2 и т.д...)
	{
		s[i].x = s[i - 1].x; // задаем Х координату i блока координатой i - 1
		s[i].y = s[i - 1].y; // то же самое делаем и с Y координатой
	}
	// далее у нас система направлений.
	if (dir == 0) s[0].y += 1; // если направление равно 0, то первый фрагмент массива перемещается на один по Y
	if (dir == 1) s[0].x -= 1; // если направление равно 1, то первый фрагмент массива перемещается на минус один по X
	if (dir == 2) s[0].x += 1; // аналогиная система
	if (dir == 3) s[0].y -= 1; // аналогичная система

	for (int i = 0; i < 10; i++) //цикл, в котором наша змея будет расти
	{
		if ((s[0].x == m.x) && (s[0].y == m.y)) // Если голова нашей змеи находится в одном блоке с фруктом, то...
		{
			num++; //...увеличиваем размер нашей змеи на 1
			m.New(); // ... запускаем функцию отрисовки нового фрукта.
		}
	}
	// Следующее нужно, что бы змея не выходила за рамка поля. Действует это просто : если змея выходит за рамки поля, то задаем
	if (s[0].x >= N-1) dir = 1; // Ей обратное направление. Например, если она выйдет за экран по высоте, то задаем ей направление, при котором она ползет
	if (s[0].y >= M-3) dir = 3; // вниз
	if (s[0].x <= 0+1) dir = 2;
	if (s[0].y <= 0+1) dir = 0;

	for (int i = 1; i < num; i++) // с помощью этого цикла мы "обрежем" змею, если она заползет сама на себя
		if (s[0].x == s[i].x && s[0].y == s[i].y) // проверка координат частей змеи, если X и Y координата головной части равно координате любого
			num = i; // другого блока змеи, то задаем ей длину, при которой "откушенная" часть отпадает.
}

void Snake() // выводим змейку на экран
{
	
	for (int i = 0; i < num; i++) // цикл отрисовки.
	{
		glRectf(s[i].x * scale, s[i].y * scale, (s[i].x + 1) * scale, (s[i].y +1) * scale); //Рисуем квадраты, те самые "блоки" змеи
	}
}

void Key(int key, int a, int b) // функция нажатия клавиш
{
	switch (key) // используем оператор switch
	{
	case 101: dir = 0; break; // при нажатии клавиш, задаем направление змеи(вверх, вниз, влево, вправо)
	case 102: dir = 2; break;
	case 100: dir = 1; break;
	case 103: dir = 3; break;
	case GLUT_KEY_END: m.New(); break;
	}
}

void Read_kb(unsigned char key, int, int)				// zoom and control
{
	if (key == 's')
		vx -= 2.0;
	if (key == 'w')
		vx += 2.0;
	if (key == 'a')
		vy -= 2.0;
	if (key == 'd')
		vy += 2.0;
	if (key == '1')
		vz -= 2.0;
	if (key == '3')
		vz += 2.0;
	if (key == '+')
		Zoom -= 2.0;
	if (key == '-')
		Zoom += 2.0;
	if (key == 27)
		exit(0);
	glutPostRedisplay();
}

void Barier() {


	glBegin(GL_LINE_LOOP);

	glColor3f(1, 0, 0);
	glVertex3f(0 + scale, 0 + scale,0);
	glVertex3f(N * scale, 0 + scale,0);
	glVertex3f(N * scale, M * scale - 20,0);
	glVertex3f(0 + scale, M * scale - 20,0);
	glEnd();
}

void Display() //функция общий отрисовки
{
	glClear(GL_COLOR_BUFFER_BIT); // очищаем окно перед началом отрисовки

	//Draw(); // вызов функции Draw, отвечающей за отрисовку сетки
	Snake(); // вызов функции Snake, отвечающей за отрисовку змейки

	for (int i = 0; i < 3; i++) // заполнение карты фруктами
		m.DrawFruct();
	Barier();
	

	glFlush(); // выводим на экран все вышеописанное
	glutSwapBuffers();
}

void timer(int = 0) // Таймер игры(промежуток времени, в котором будет производится все процессы)
{
	Display(); // Вызов функций  
	tick();
	glutTimerFunc(100, timer, 0); // новый вызов таймера( 100 - промежуток времени(в милисекундах), через который он будет вызыватся, timer - вызываемый паблик)
}

int main(int argc, char** argv) // Главная функция
{
	std::cout << "Snake by Alexey Ovchinnikov :P\n Loading..."; // крутой текст в консоле при загрузке
	srand(time(0));
	for (int i = 0; i < 10; i++) // начальная, самая первая отрисовка фруктов
		m.New();

	s[0].x = 10; // начальное положение змейки по X
	s[0].y = 10; // и Y координате
	s[0].z = 0;
	// следующие функции абсолютно идиентичных почти во всех программах на OpenGL, так то запоминать их не обязательно, кроме ...
	
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(w, h); // ... этой, она создаем окно (w - ширина, h - высота)
	glutCreateWindow("Game"); // ... этой, она задает название окна
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, 520, 0, 520);
	glutDisplayFunc(Display); // ... и этой, она вызывает начальную функцию, в нашем случае это главная функция отрисовки - Display
	glutSpecialFunc(Key);
	glutKeyboardFunc(Read_kb);
	glutTimerFunc(50, timer, 0); // ... Ну и в начале программы задаем рекурсивный таймер.
	glutMainLoop();

	return 0;
}